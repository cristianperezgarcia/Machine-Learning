# -*- coding: utf-8 -*-
"""Regresion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17pMqs5-uqQcsPTrHWHHtYdEfoKIS3-eC

# Regresión Lineal Simple Utilizando Datos de Automóviles

## Introducción
En este cuaderno, realizaremos un análisis de regresión lineal  utilizando el conjunto de datos de millas por galón (MPG) de automóviles. El objetivo es predecir la autonomía de un automóvil en función de la potencia en caballos.

## Carga y Preparación de Datos
Primero, importamos las bibliotecas necesarias y cargamos los datos.
"""

# Importamos las bibliotecas necesarias para el análisis
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

"""Vamos a utilizar un conjunto de datos del repositorio de la Universidad de California, Irvine (UCI ML repository):

[Auto MPG](https://archive.ics.uci.edu/dataset/9/auto+mpg)
"""

# Definimos la URL del conjunto de datos
url = "https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data"

# Especificamos los nombres de las columnas
column_names = ['MPG', 'Cylinders', 'Displacement', 'Horsepower', 'Weight', 'Acceleration', 'Model Year', 'Origin', 'Car Name']

# Cargamos los datos en un DataFrame de pandas
data = pd.read_csv(url, delim_whitespace=True, names= column_names, na_values='?')

# Eliminamos las columnas 'Car Name' y 'Origin' ya que no es relevante para nuestro análisis
data = data.drop('Car Name',axis = 1)

data = data.drop('Origin',axis = 1)

# Mostramos las primeras filas del DataFrame
data

#Colocamos la variable objetivo al final
data = data[['Cylinders', 'Displacement', 'Horsepower', 'Weight', 'Acceleration', 'Model Year', 'MPG']]
data

"""## Preprocesamiento de Datos
Preparamos los datos para el análisis, tratando los valores faltantes y seleccionando las columnas relevantes.

"""

data.info()

# Observamos que en la columna Horsepower hay 8 datos faltantes. En esta ocasión, vamos simplemente a eliminar las filas
# con los valores faltantes.

data = data.dropna() #con esta funcion nos cargamos directamente las filas
data.info()

"""## Análisis de Regresión Lineal

Primero llevaremos a cabo un modelo de regresión lineal con una sola variable predictora

Modelo lineal:

 $$y =  \beta_0 + \beta_1x + \varepsilon$$




Función a minimizar:

 $$S = \sum_{i=1}^{N} (y_i - (\beta_0 + \beta_1x_i))^2$$
"""

# Seleccionamos 'Horsepower' como variable independiente (predictora) y 'MPG' como variable dependiente (objetivo)
X = data[['Horsepower']]#para que me quede como un data frame hay que poner dos veces corchetes
y = data['MPG']

"""
## División de Datos en Conjuntos de Entrenamiento y Prueba
Dividimos los datos en un conjunto de entrenamiento y otro de prueba para poder evaluar el rendimiento de nuestro modelo.
"""

# Establecemos una semilla para la reproducibilidad
np.random.seed(0)

# Mezclamos los datos de forma aleatoria
shuffled_indices = np.random.permutation(len(data))
shuffled_indices

# Calculamos el tamaño del conjunto de prueba (20% de los datos)
test_set_size = int(len(data)*0.2)

# Creamos los índices para los conjuntos de prueba y entrenamiento
test_indices = shuffled_indices[:test_set_size]
train_indices = shuffled_indices[test_set_size:]
test_indices

# Creamos los conjuntos de prueba y entrenamiento
train_set = data.iloc[train_indices]#aplicamos la mascara
test_set = data.iloc[test_indices]

# Seleccionamos 'Horsepower' como variable independiente (predictora) y 'MPG' como variable dependiente (respuesta) para ambos conjuntos
X_train = train_set[['Horsepower']]
y_train = train_set['MPG']
X_test = test_set[['Horsepower']]
y_test = test_set['MPG']
X_train

X_train = train_set[['Horsepower']]
type(X_train)

"""## Construcción y Entrenamiento del Modelo de Regresión Lineal
Construimos el modelo de regresión lineal y lo entrenamos con el conjunto de entrenamiento.

"""

# Creamos una instancia del modelo de regresión lineal
model = LinearRegression()

# Entrenamos el modelo con los datos de entrenamiento
model.fit(X_train,y_train)

# Realizamos predicciones utilizando el conjunto de prueba
y_pred =  model.predict(X_test)

"""## Evaluación del Modelo con una variable predictora
Evaluamos el modelo usando el conjunto de prueba y calculamos métricas como el error cuadrático medio (MSE). El MSE se define como:

$$ MSE = \frac{1}{N} \sum_{i=1}^{N} (y_i^* - \hat{y}_i)^2 $$

donde $y_i$ son los valores observados, $\hat{y}_i$ son los valores predichos por el modelo, y $n$ es el número de observaciones.

"""

# Imprimimos los coeficientes del modelo y el error cuadrático medio
print('Término independiente: beta_0:', model.intercept_)
print('Coeficiente: beta_1:', model.coef_)

mse_1variable = mean_squared_error(y_test,y_pred)
print('Error cuadrático medio: %.2f' % mse_1variable)

"""## Predicción con cada una de las variables"""

# Variables predictoras
predictors = ['Cylinders', 'Displacement', 'Horsepower', 'Weight', 'Acceleration', 'Model Year']

# Dividimos los datos en conjuntos de entrenamiento y prueba usando librería
X = data[predictors]
y = data['MPG']
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size = 0.2, random_state = 0)

# Diccionario para almacenar los MSEs  (almacenamos los errores)
mse_values = {}

# Entrenar un modelo para cada variable predictora y calcular el MSE
for predictor in predictors:
    X_train_single = X_train[[predictor]] #(tiene todas las variables predictoras, pero vamos a coger una )
    X_test_single = X_test[[predictor]]

    model = LinearRegression()
    model.fit(X_train_single, y_train)

    y_pred = model.predict(X_test_single)#predecimos
    mse = mean_squared_error(y_test, y_pred)
    mse_values[predictor] = mse

# Mostrar los MSEs
for predictor, mse in mse_values.items():
    print(f"MSE utilizando {predictor}: {mse}")

# Identificar la variable con el menor MSE
min_mse_predictor = min(mse_values, key=mse_values.get)
print(f"\nLa variable que produce el menor MSE es: {min_mse_predictor} con un MSE de {mse_values[min_mse_predictor]}")